<!DOCTYPE html>
<!-- saved from url=(0066)https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Data fingerprinting</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="./Data fingerprinting_files/vue.css">
</head>
<body data-page="fingerprinting.md" class="ready sticky" data-new-gr-c-s-check-loaded="14.1229.0" data-gr-ext-installed="">
  <script src="./Data fingerprinting_files/docsify-edit-on-github"></script>

  <a href="https://github.com/sbaresearch/data-fingerprinting" target="_blank" class="github-corner" aria-label="View source on Github"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main><button class="sidebar-toggle" aria-label="Menu"><div class="sidebar-toggle-button"><span></span><span></span><span></span></div></button><aside class="sidebar"><h1 class="app-name"><a class="app-name-link" data-nosearch="" href="https://sbaresearch.github.io/data-fingerprinting/">data-fingerprinting</a></h1><div class="sidebar-nav"><ul><li><a href="https://sbaresearch.github.io/data-fingerprinting/#/" title="SPEML: Exercise 1">SPEML: Exercise 1</a><ul><li><a href="https://sbaresearch.github.io/data-fingerprinting/#/phase1" title="Phase 1">Phase 1</a></li><li><a href="https://sbaresearch.github.io/data-fingerprinting/#/_phase2" title="Phase 2">Phase 2</a></li></ul></li><li><a href="https://sbaresearch.github.io/data-fingerprinting/#/submission" title="Submission guidelines">Submission guidelines</a></li><li><a href="https://sbaresearch.github.io/data-fingerprinting/#/datasets" title="Datasets">Datasets</a></li><li class="active"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting" title="Data fingerprinting">Data fingerprinting</a></li></ul></div></aside><section class="content"><article class="markdown-section" id="main"><div style="overflow: auto"><p style="float: right"><a style="text-decoration: underline; cursor: pointer" onclick="EditOnGithubPlugin.onClick(event)">Edit on github</a></p></div><h1 id="data-fingerprinting"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=data-fingerprinting" data-id="data-fingerprinting" class="anchor"><span>Data fingerprinting</span></a></h1><h2 id="overview"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=overview" data-id="overview" class="anchor"><span>Overview</span></a></h2><p>A fingerprint is a personalised, secret piece of information identifying both the data owner and the recipient of the data. 
By embedding the fingerprint into the data, the owner achieves two main goals: </p><ol><li><strong>tracing of the unauthorised data redistributor</strong></li><li><strong>ownership verification</strong></li></ol><p>The fingerprint system is a two-stage process: </p><p><img src="./Data fingerprinting_files/fingerprinting-system.svg" data-origin="static/images/fingerprinting-system.svg" alt="fingerprinting-system"></p><p>The main properties of the fingerprinting system include:</p><ul><li>security - without access to the secret key, the fingerprint detection process cannot be performed correctly</li><li>blindness - the fingerprint extraction does not require access to the original data</li><li>public system - the fingerprinting system assumes that the method used for embedding the mark is public. Defence only lies in the choice of the private parameters (owner's secret key)</li><li>robustness - the fingerprint can not be removed via benign data updates and malicious attacks without rendering the data useless</li><li>utility - the fingerprint introduces only minor, insignificant modifications to the data</li></ul><h2 id="similarity-based-fingerprinting"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=similarity-based-fingerprinting" data-id="similarity-based-fingerprinting" class="anchor"><span>Similarity-based fingerprinting</span></a></h2><p>Traditional fingerprinting methods [1,2] rely on pseudo-random modification of the data values and are originally designed for large numerical data, assuming a great embedding space. 
Their effectiveness falls short for real-life datasets with limited domains, which is usually case for categorical types, and they affect the semantic coherence with newly embedded random values [3]. 
Therefore, additional methods have been proposed that consider preserving statistical moments in the data, aiming to keep fingerprint robustness high in both single- and multi-attacker scenarios [4-6]. 
Similarity-based fingerprinting leverages (i) pseudo-random embedding pattern for secrecy and detectability of the fingerprint and (ii) neighbourhood search similar to kNN algorithm for preserving the data utility. 
Building upon an earlier non-blind approach [7] (see <em>blindness</em> property above), the fingerprint is embedded by sampling the values from the existing distributions in the dataset, ensuring the high utility of the fingerprinted data while keeping the robustness of the fingerprint.</p><p>A fingerprint is an <em>L</em>-bit sequence where each bit determines how the new value will be sampled at a pseudo-random position in the dataset. For each selected data value, there is a 50% chance the new value will be sampled from a low-density area of the value distribution in similar records and a 50% chance to be sampled from a high-density area of the value distribution in similar records. 
For example, below we show how a value distribution in similar records (the <em>neighbourhood</em>) might look like for a chosen data value. If the marking bit is 0 as depicted below, the new marked value is sampled from the low-density area (e.g. below 75th percentile). </p><p><img src="./Data fingerprinting_files/demo.png" data-origin="static/images/demo.png" alt="demo-sampling"></p><p>During the fingerprint detection, this process is reversed to decode the embedded bit. Hence, if the value falls in the low-density area, the embedded bit is assumed to be 0, otherwise 1. These extracted bit assumptions are added to the voting system. Each of the <em>L</em> fingerprint bit gets assigned votes for the bit being 0 or 1. For <em>L</em>=16, the final voting might look like this:</p><p><img src="./Data fingerprinting_files/demo-fpvotes.png" data-origin="static/images/demo-fpvotes.png" alt="demo-votes"></p><p>The upper row represents the votes for bit 0 per bit-position, and the lower row represents the votes for bit 1 per bit-position. According to the majority vote, the fingerprint is decided to be the 16-bit sequence: 0100000001100100 which in a correct setup is the exact sequence associated to the recipient of the data copy. In reality, the fingerprint sequences are much longer (&gt;100-bit) to ensure a small mutual overlap.</p><h3 id="demo-example"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=demo-example" data-id="demo-example" class="anchor"><span>Demo example:</span></a></h3><p>Let's assume we want to fingerprint the fragment of <a href="https://archive.ics.uci.edu/dataset/14/breast+cancer" target="_blank" rel="noopener">Breast Cancer dataset</a>.
<img src="./Data fingerprinting_files/demo-data.png" data-origin="static/images/demo-data.png" alt="breast-cancer-fragment"></p><p>The fingerprint we want to embed is <em>1110 0001 0011 1100</em> (see: Fingerprint generation).</p><p>In each iteration (for each record), a pseudo-random number generator (PRNG) decides on the following:</p><ul><li><strong>IF</strong> the records will be marked</li><li><strong>WHERE</strong> in the record should the mark be</li><li><strong>WHICH</strong> fingerprint bit shall be embedded</li><li><strong>HOW</strong> the fingerprint bit shall be embedded</li></ul><p><img src="./Data fingerprinting_files/demo-prng-embedding-general.png" data-origin="static/images/demo-prng-embedding-general.png" alt="pnrg-embedding-general"></p><p><img src="./Data fingerprinting_files/demo-prng-embedding.png" data-origin="static/images/demo-prng-embedding.png" alt="prng-embedding"></p><p>To select the new value, we look at similar records and the distribution of the target attribute in those records. For the target values, we construct a frequency list (categorical) or probability density function (ratio attributes).
Based on the mark bit, we have two possible outcomes, either to sample from low-frequency area (mark bit=0) or high-frequency are (mark bit=1). In this case, the mark bit is 1 so we sample from high-frequency area, i.e. choose the most frequent value.</p><p><img src="./Data fingerprinting_files/demo-embedding-sampling.PNG" data-origin="static/images/demo-embedding-sampling.PNG" alt="embedding-sampling"></p><p>The marked record then looks like this (Although it preserves the original value, the bit is embedded. More often, the marked value will actually change):
<img src="./Data fingerprinting_files/demo-marked-record.png" data-origin="static/images/demo-marked-record.png" alt="marked-record"></p><p>The detection algorithm works in reverse; we show the same iteration (for the same record) of the detection algorithm.</p><p><img src="./Data fingerprinting_files/demo-prng-detection.png" data-origin="static/images/demo-prng-detection.png" alt="prng-detection"></p><p>To extract the value of the fingerprint bit, we look where in the frequency plot the target value falls. If it is the most frequent value, like in this case, then the mark bit must have been 1. Otherwise, it would have been detected as 0.
Then, to revert the <em>mark</em> bit into the fingerprint bit, we xor it with the mask bit (like we did in the insertion) - in this iteration mask bit=1, and finally obtain 0 as the fingerprint bit.
We then update the vote that the fingerprint bit at position 3 is 0 and continue extracting from other records:</p><p><img src="./Data fingerprinting_files/demo-detection.png" data-origin="static/images/demo-detection.png" alt="demo-detection"></p><p>The final fingerprint will be the majority vote over all fingerprint bits. Here is an example of the voting progression through the detection (note that sometimes errors can be made):
 <img src="./Data fingerprinting_files/demo-voting.png" data-origin="static/images/demo-voting.png" alt="demo-voting"></p><h2 id="fingerprint-generation"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=fingerprint-generation" data-id="fingerprint-generation" class="anchor"><span>Fingerprint generation</span></a></h2><p>The input to the insertion (embedding) algorithm is a fingerprint: a bit sequence that encodes the owner's secret key and the recipient's ID. To create such a sequence, we need to make sure that (i) each recipient gets a unique fingerprint such that a unique recipient's ID can be recovered from the fingerprint and (ii) the sequence is secret. However, one additional requirement is key to resistance against collusion attacks (see: Vulnerabilities). The fingerprint should be designed such that it is possible to infer with some confidence if there was a collusion and which recipients colluded. We call these <em>collusion-resistant codes</em>.
Below is a summary of some fingerprint types:</p><p><img src="./Data fingerprinting_files/collusion.PNG" data-origin="static/images/collusion.PNG" alt="collusion"></p><h2 id="virtual-record-uid"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=virtual-record-uid" data-id="virtual-record-uid" class="anchor"><span>Virtual record UID</span></a></h2><p>The PRNG-based methods, like this one, depend on the record UID to find the locations for marks and marks themselves. The records' UIDs might be crucial for the data table, so they are not always easily removable. However, they can still be prone to manipulation. In this case, the UIDs can be extracted from the record itself by e.g. combining a few attribute values into a representative, unique ID of the record.</p><h2 id="vulnerabilities"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=vulnerabilities" data-id="vulnerabilities" class="anchor"><span>Vulnerabilities</span></a></h2><p>Fingerprints can be subject to malicious manipulations or benign updates of the dataset, in which case they should retain high robustness. 
There are two main threat scenarios for fingerprinting:</p><ol><li>Single-user attacks: the attacker is a data recipient who only has access to one (their own) data copy. In that case, they might modify data values, remove records, modify record UIDs, modify whole attributes etc., while trying to preserve the utility of the data (assumed downstream task, data statistics, etc.).</li><li>Collusion attacks: the attackers are data recipients who decide to collaboratively remove the fingerprint. This usually relies on observing differences among data copies and modifying the diverging values by, e.g. averaging them, substituting with new values, etc.</li></ol><h2 id="getting-started"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=getting-started" data-id="getting-started" class="anchor"><span>Getting started</span></a></h2><h3 id="installation"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=installation" data-id="installation" class="anchor"><span>Installation</span></a></h3><p>You can use the fingerprinting tool by cloning this repository:</p><pre v-pre="" data-lang=""><code class="lang-">$ git clone https://github.com/sbaresearch/data-fingerprinting.git</code></pre><p>Install dependencies:</p><pre v-pre="" data-lang=""><code class="lang-">pip install -r requirements.txt</code></pre><h3 id="fingerprint-embedding"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=fingerprint-embedding" data-id="fingerprint-embedding" class="anchor"><span>Fingerprint embedding</span></a></h3><p>Run <code>embedding.py</code> with arguments specifying:</p><ul><li>data file</li><li>secret key (used also to correctly detect the fingerprint)</li><li>user's ID</li></ul><p>Optional arguments include fingerprint parameters such as gamma (a probability of marking a single record is 1/gamma), fingerprint length, output file, log file and config file where some additional parameters can be specified.</p><p>For example, the command:</p><pre v-pre="" data-lang=""><code class="lang-">python embedding.py speml/Financial_Records_Demo.csv 177264 10 </code></pre><p>will run the embedding on the dataset speml/Financial_Records_Demo.csv with (your) secret key 177264 for the recipient with the ID=10 (for simplicity, we keep the user IDs as sequential integers).
It will also read the example config file <code>speml/config.json</code>. The embedding might take a few minutes.</p><p>The fingerprinted data is by default written in <code>speml/fingerprinted_output.csv</code> in the root directory (this can be changed by specifying argument <code>--out [another_dest].csv</code>).</p><p>The script will also output a <code>speml/log.json</code> file consisting of the summary of used parameters. These exact parameters need to be used in the detection process for the correct fingerprint extraction (along with the correct secret key).</p><h3 id="fingerprint-detection"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=fingerprint-detection" data-id="fingerprint-detection" class="anchor"><span>Fingerprint detection</span></a></h3><p>Run <code>detection.py</code> with arguments specifying:</p><ul><li>data file</li><li>secret key (only the correct secret key will lead to successful detection)</li></ul><p>Optional arguments include fingerprint parameters such as gamma, fingerprint length, output file, log file and config file where some additional parameters can be specified.
Note that you <em>need</em> to use the same parameters as in the embedding.</p><p>Continuing from the embedding example, the command:</p><pre v-pre="" data-lang=""><code class="lang-">python detection.py speml/fingerprinted_output.csv 177264  </code></pre><p>will run the detection algorithm on <code>speml/fingerprinted_output.csv</code> file with your secret key 1177264. 
The expected output is the ID of the user (in this case, 10) and detection confidence (1.0 for a perfect match).</p><p><em>Troubleshooting:</em> If the detection fails in a seemingly normal scenario, it might be due to a couple of preventable reasons. 
Firstly, the passed arguments and fingerprint parameters need to match exactly, so double-check the passed arguments and config file. 
Secondly, sometimes the choice of parameters (mainly gamma and fingerprint length) is not robust enough for given dataset; the rule of thumb is to ensure #data_records/(gamma*fp_len)&gt;20.
If you run into other issues, feel free to contact us.</p><h2 id="references"><a href="https://sbaresearch.github.io/data-fingerprinting/#/fingerprinting?id=references" data-id="references" class="anchor"><span>References:</span></a></h2><p>[1] Li, Y., Swarup, V. and Jajodia, S., 2005. Fingerprinting relational databases: Schemes and specialties. IEEE Transactions on Dependable and Secure Computing, 2(1), pp.34-45.<br>[2] Al Solami, E., Kamran, M., Saeed Alkatheiri, M., Rafiq, F. and Alghamdi, A.S., 2020. Fingerprinting of relational databases for stopping the data theft. Electronics, 9(7), p.1093.<br>[3] Šarčević, T. and Mayer, R., 2019. An evaluation on robustness and utility of fingerprinting schemes. In Machine Learning and Knowledge Extraction: Third IFIP TC 5, TC 12, WG 8.4, WG 8.9, WG 12.9 International Cross-Domain Conference, CD-MAKE 2019, Canterbury, UK, August 26–29, 2019, Proceedings 3 (pp. 209-228). Springer International Publishing.<br>[4] Yilmaz, E. and Ayday, E., 2020. Collusion-resilient probabilistic fingerprinting scheme for correlated data. arXiv preprint arXiv:2001.09555.<br>[5] Kieseberg, P., Schrittwieser, S., Mulazzani, M., Echizen, I. and Weippl, E., 2014. An algorithm for collusion-resistant anonymization and fingerprinting of sensitive microdata. Electronic Markets, 24, pp.113-124.<br>[6] Ji, T., Ayday, E., Yilmaz, E. and Li, P., 2022. Towards robust fingerprinting of relational databases by mitigating correlation attacks. IEEE transactions on dependable and secure computing, 20(4), pp.2939-2953.<br>[7] Sarcevic, T. and Mayer, R., 2020. A correlation-preserving fingerprinting technique for categorical data in relational databases. In ICT Systems Security and Privacy Protection: 35th IFIP TC 11 International Conference, SEC 2020, Maribor, Slovenia, September 21–23, 2020, Proceedings 35 (pp. 401-415). Springer International Publishing.\</p></article></section></main>
  <script>
    window.$docsify = {
      name: 'data-fingerprinting',
      repo: 'https://github.com/sbaresearch/data-fingerprinting',
      coverpage: false,
      loadSidebar: true,
      plugins: [EditOnGithubPlugin.create('https://github.com/sbaresearch/data-fingerprinting/blob/speml/docs/')]
    }
  </script>
  <!-- Docsify v4 -->
  <script src="./Data fingerprinting_files/docsify@4"></script>


<div class="progress" style="opacity: 0; width: 0%;"></div></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>